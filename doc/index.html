<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta id="repository-name" content="github.com/drujensen/kemalyst">
  <link href="css/style.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="js/doc.js"></script>
  <title>README - github.com/drujensen/kemalyst</title>
</head>
<body>

<div id="types-list">
  <div id="search-box">
    <input type="search" id="search-input" placeholder="Search...">
  </div>

  <ul>
    <li class="current"><a href="index.html">README</a></li>
  </ul>

  <ul>
  
  <li class="parent " data-id="github.com/drujensen/kemalyst/Kemalyst" data-name="kemalyst">
      <a href="Kemalyst.html">Kemalyst</a>
      
        <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Application" data-name="kemalyst::application">
      <a href="Kemalyst/Application.html">Application</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Controller" data-name="kemalyst::controller">
      <a href="Kemalyst/Controller.html">Controller</a>
      
    </li>
  
  <li class="parent " data-id="github.com/drujensen/kemalyst/Kemalyst/Exceptions" data-name="kemalyst::exceptions">
      <a href="Kemalyst/Exceptions.html">Exceptions</a>
      
        <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Exceptions/Forbidden" data-name="kemalyst::exceptions::forbidden">
      <a href="Kemalyst/Exceptions/Forbidden.html">Forbidden</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Exceptions/RouteNotFound" data-name="kemalyst::exceptions::routenotfound">
      <a href="Kemalyst/Exceptions/RouteNotFound.html">RouteNotFound</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler" data-name="kemalyst::handler">
      <a href="Kemalyst/Handler.html">Handler</a>
      
        <ul>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Base" data-name="kemalyst::handler::base">
      <a href="Kemalyst/Handler/Base.html">Base</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/BasicAuth" data-name="kemalyst::handler::basicauth">
      <a href="Kemalyst/Handler/BasicAuth.html">BasicAuth</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Block" data-name="kemalyst::handler::block">
      <a href="Kemalyst/Handler/Block.html">Block</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/CORS" data-name="kemalyst::handler::cors">
      <a href="Kemalyst/Handler/CORS.html">CORS</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/CSRF" data-name="kemalyst::handler::csrf">
      <a href="Kemalyst/Handler/CSRF.html">CSRF</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Error" data-name="kemalyst::handler::error">
      <a href="Kemalyst/Handler/Error.html">Error</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Logger" data-name="kemalyst::handler::logger">
      <a href="Kemalyst/Handler/Logger.html">Logger</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Params" data-name="kemalyst::handler::params">
      <a href="Kemalyst/Handler/Params.html">Params</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Route" data-name="kemalyst::handler::route">
      <a href="Kemalyst/Handler/Route.html">Route</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Router" data-name="kemalyst::handler::router">
      <a href="Kemalyst/Handler/Router.html">Router</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Session" data-name="kemalyst::handler::session">
      <a href="Kemalyst/Handler/Session.html">Session</a>
      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/Handler/Static" data-name="kemalyst::handler::static">
      <a href="Kemalyst/Handler/Static.html">Static</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="github.com/drujensen/kemalyst/Kemalyst/WebSocket" data-name="kemalyst::websocket">
      <a href="Kemalyst/WebSocket.html">WebSocket</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

</div>

<div id="main-content">
<h3>WIP (Work In Progress)</h3>

<p><a href="https://travis-ci.org/drujensen/kemalyst" target="_blank"><img src="https://travis-ci.org/drujensen/kemalyst.svg?branch=master" alt="Build Status"/></a></p>

<p><a href="http://docrystal.org/github.com/drujensen/kemalyst" target="_blank"><img src="http://docrystal.org/badge.svg" alt="docrystal.org"/></a></p>

<h1>Kemalyst</h1>

<p>Kemalyst is a yarlf (yet another rails like framework) that is based on on
super fast <a href="https://github.com/sdogruyol/kemal" target="_blank">kemal</a>. The framework
leverages the http handlers which are similar to Rack middleware.</p>

<p>The router and controllers are an extension of the same middleware so you can
chain any compatible HTTP::Handler before or after the routing handler so you
can limit a particular handler to a sub-tree of your routes.</p>

<p>The model is a simple ORM mapping and supports MySQL, PG and SQLite.</p>

<p>The views are handled using <a href="https://github.com/jeromegn/kilt" target="_blank">kilt</a> and several macros to simplify
development.</p>

<h2>Installation</h2>

<ol><li>Install Crystal</li></ol>

<p>You can find instructions on how to install Crystal from [Crystal's
Website](http://crystal-lang.org).  I recommend using
<a href="https://github.com/pine613/crenv" target="_blank">crenv</a> to manage your crystal versions.</p>

<ol><li>Create a Crystal App</li></ol>

<pre><code>crystal init app [your_app]
cd [your_app]</code></pre>

<ol><li>Add kemalyst dependency to your shard.yml</li></ol>

<pre><code>dependencies:
  kemalyst:
    github: drujensen<span class="s">/kemalyst
    branch: master
  # optional
  pg:
    github: will/</span>crystal<span class="o">-</span>pg
    branch: master
  mysql:
    github: waterlink<span class="s">/crystal-mysql
    branch: master
  sqlite3:
    github: manastech/</span>crystal<span class="o">-</span>sqlite3
    branch: master</code></pre>

<p>and run <code>shards update</code>.</p>

<h3>Post Install</h3>

<p>To keep a similar structure to yarlf, several directories and files will be
installed.  This structure should look familiar to you if your coming from a
Rails background.</p>

<p>You may want to remove the remnants of <code>crystal init</code>:</p>

<pre><code>rm <span class="o">-</span>r src<span class="s">/&#91;your_app&#93;
rm spec/</span>[your_app_spec].cr
rm spec<span class="s">/spec_helper.cr_old</code></pre>

<h2>Usage</h2>

<h3>Run Locally</h3>

<p>To test the demo app locally:</p>

<ol><li>create a postgres database called <code>[your_app]</code></li><li>run <code>export DATABASE_URL=postgres://[username]:[password]@localhost:5432/[your_app]</code></li><li>migrate the database: <code>crystal db/migrate.cr</code></li><li>run the specs: <code>crystal spec</code></li></ol>

<p>To build the demo app locally:</p>

<ol><li>build the app <code>crystal build --release src/app.cr</code></li><li>run with <code>./app</code></li><li>visit <code>http://0.0.0.0:3000/</code></li></ol>

<h3>Run with docker compose</h3>

<p>To run the demo app, we are including a Dockerfile and docker-compose.yml. If
you have docker setup, you should be able to run:</p>

<pre><code>docker<span class="o">-</span>compose build
docker<span class="o">-</span>compose run web crystal db<span class="s">/migrate.cr
docker-compose up web</code></pre>

<p>This will download an ubuntu/cedar image compatible with heroku and has all the
dependencies installed including crystal.</p>

<p>Now you should be able to hit the site:</p>

<pre><code>open <span class="s">&quot;http://&#36;&#40;docker-machine ip default&#41;&quot;</span></code></pre>

<h3>Cookie Session</h3>

<p>You will need to set a secret for the session.  Run the following
command:</p>

<pre><code>crystal eval <span class="s">&quot;require \&quot;secure_random\&quot;; puts SecureRandom.hex&#40;64&#41;&quot;</span></code></pre>

<p>copy the secret and set this in <code>config/session.cr</code>.</p>

<h3>Sample Applications</h3>

<p>Several sample applications are provided:</p>

<p><a href="https://github.com/drujensen/blog-kemalyst" target="_blank">Blog Kemalyst</a>
<a href="https://github.com/drujensen/chat-kemalyst" target="_blank">Chat Kemalyst</a>
<a href="https://github.com/drujensen/todo-backend-kemalyst" target="_blank">ToDo Backend Kemalyst</a></p>

<h3>Configure App</h3>

<p>All config settings are in the <code>/config</code> folder.  Each handler has its own
settings.  You will find the <code>database.yml</code> and <code>routes.cr</code> here. Checkout
the samples that demonstrates a traditional blog site and a websocket chat
app.</p>

<h3>Middleware HTTP::Handlers</h3>

<p>There are 6 handlers that are pre-configured for Kemalyst:</p>

<ul><li>Logger.instance(@logger) - Logs all requests/responses to the <code>@logger</code> provided</li><li>Error.instance - Handles any Exceptions and renders a response.</li><li>Static.instance - Delivers any static assets from the <code>./public</code> folder.</li><li>Session.instance - Provides a Cookie Session that can be accessed from the <code>context.session</code></li><li>Params.instance - Unifies the parameters into <code>context.params</code></li><li>Router.instance - Routes requests to other handlers\controllers based on the HTTP method and path.</li></ul>

<p>Other handlers available for Kemalyst:</p>

<ul><li>BasicAuth.instance(username, password) - Provides Basic Authentication.</li><li>CORS.instance - Handles Cross Origin Resource Sharing.</li><li>CSRF.instance - Helps prevent Cross Site Request Forgery.</li></ul>

<p>You may want to add, replace or remove handlers based on your situation.  You can do that in the
Application configuration <code>config/application.cr</code>:</p>

<pre><code><span class="t">Kemalyst</span><span class="t">::</span><span class="t">Application</span>.config <span class="k">do</span> <span class="o">|</span>config<span class="o">|</span>
  <span class="c"># handlers will be chained in the order provided</span>
  config.handlers <span class="o">=</span> [
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Logger</span>.instance(config.logger),
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Error</span>.instance,
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Params</span>.instance,
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">CORS</span>.instance, <span class="c"># Enable CORS</span>
    <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Handler</span><span class="t">::</span><span class="t">Router</span>.instance
  ]
<span class="k">end</span></code></pre>

<h3>Router</h3>

<p>The router will perform a lookup based on the method and path and return the
chain of handlers you specify in the routes.cr file.</p>

<p>An example of a route would be:</p>

<pre><code>get <span class="s">&quot;/&quot;</span>,   <span class="t">DemoController</span><span class="t">::</span><span class="t">Index</span>.instance</code></pre>

<p>You may chain multiple handlers in a route using an array:</p>

<pre><code>get <span class="s">&quot;/&quot;</span>, [ <span class="t">BasicAuth</span>.instance(<span class="s">&quot;username&quot;</span>, <span class="s">&quot;password&quot;</span>),
           <span class="t">DemoController</span><span class="t">::</span><span class="t">Index</span>.instance ]</code></pre>

<p>This is how you would configure a WebSocket Controller:</p>

<pre><code>get <span class="s">&quot;/&quot;</span>, [ <span class="t">ChatController</span><span class="t">::</span><span class="t">Chat</span>.instance,
           <span class="t">ChatController</span><span class="t">::</span><span class="t">Index</span>.instance ]</code></pre>

<p>See below for more information on how to create a WebSocket Controller.</p>

<p>You can use any of the following methods: <code>get, post, put, patch, delete, all</code></p>

<p>You can use a <code>*</code> to chain a handler for all children of this path:</p>

<pre><code>all    <span class="s">&quot;/posts/*&quot;</span>,   <span class="t">BasicAuth</span>.instance(<span class="s">&quot;admin&quot;</span>, <span class="s">&quot;password&quot;</span>)

<span class="c"># all of these will be secured with the BasicAuth handler.</span>
get    <span class="s">&quot;/posts/:id&quot;</span>, <span class="t">DemoController</span><span class="t">::</span><span class="t">Show</span>.instance
put    <span class="s">&quot;/posts/:id&quot;</span>, <span class="t">DemoController</span><span class="t">::</span><span class="t">Update</span>.instance
delete <span class="s">&quot;/posts/:id&quot;</span>, <span class="t">DemoController</span><span class="t">::</span><span class="t">Delete</span>.instance
</code></pre>

<p>You can use <code>:variable</code> in the path and it will set a
context.params["variable"] to the value in the url.</p>

<h3>Controllers</h3>

<p>The Controller inherits from HTTP::Handler which is the middleware similar to
Rack's middleware.  The handlers are chained together in a linked-list and
each will perform some action against the HTTP::Server::Context and then call
the next handler in the chain.  The router will continue this chain for a
specific route.  The final handler should return the String that will be
rendered as the body and then the chain will unwind and perform post handling.</p>

<p>An example of a controller:</p>

<pre><code><span class="k">require</span> <span class="s">&quot;../models/post&quot;</span>

<span class="k">class</span> <span class="t">Index</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Controller</span>
  <span class="k">def</span> <span class="m">call</span>(context)
    posts <span class="o">=</span> <span class="t">Post</span>.all(<span class="s">&quot;ORDER BY created_at DESC&quot;</span>)
    render <span class="s">&quot;post/index.ecr&quot;</span>, <span class="s">&quot;main.ecr&quot;</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>There are several helper macros that set content type and response.</p>

<pre><code>  render   <span class="s">&quot;filename.ecr&quot;</span>       <span class="c"># renders an .ecr template</span>
  render   <span class="s">&quot;filename.ecr&quot;</span>, <span class="s">&quot;layout.ecr&quot;</span> <span class="c"># renders an .ecr template with layout</span>
  redirect <span class="s">&quot;path&quot;</span>               <span class="c">#redirect to path</span>
  text     <span class="s">&quot;body&quot;</span>, <span class="n">200</span>          <span class="c">#render text/plain with status code of 200</span>
  json     <span class="s">&quot;&#123;&#125;&quot;</span>.to_json, <span class="n">200</span>    <span class="c">#render application/json with status code of 200</span>
  html     <span class="s">&quot;&lt;html&gt;&lt;/html&gt;&quot;</span>, <span class="n">200</span> <span class="c">#render text/html with status code of 200</span></code></pre>

<h3>WebSocket Controllers</h3>

<p>The WebSocket Controller will handle upgrading a HTTP Request to a WebSocket
Connection.</p>

<p>An example WebSocket Controller:</p>

<pre><code class='language-crystal'><span class="k">class</span> <span class="t">Chat</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">WebSocket</span>
  @sockets <span class="o">=</span> <span class="o">[]</span> <span class="k">of</span> <span class="t">HTTP</span><span class="t">::</span><span class="t">WebSocket</span>
  @messages <span class="o">=</span> <span class="o">[]</span> <span class="k">of</span> <span class="t">String</span>
   
  <span class="k">def</span> <span class="m">call</span>(socket : <span class="t">HTTP</span><span class="t">::</span><span class="t">WebSocket</span>)
    @sockets.push socket
    socket.on_message <span class="k">do</span> <span class="o">|</span>message<span class="o">|</span>
      @messages.push message
      @sockets.each <span class="k">do</span> <span class="o">|</span>a_socket<span class="o">|</span>
        a_socket.send @messages.to_json
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre>

<p>The <code>Chat</code> class will override the <code>call</code> method that is expecting an
<code>HTTP::WebSocket</code> to be passed which it would maintain and properly handle
messages to and from each socket.</p>

<p>This class will manage an array of <code>HTTP::Websocket</code>s and configures the
<code>on_message</code> callback that will manage the messages that will be then be
passed on to all of the other sockets. </p>

<p>To see a full example application, checkout
<a href="https://github.com/drujensen/chat-kemalyst" target="_blank">Chat Kemalyst</a></p>

<h3>Views</h3>

<p>Views are rendered using <a href="http://github.com/jeromegn/kilt" target="_blank">Kilt</a>.  Currently,
there are 4 different templating languages supported by Kilt: <code>ecr</code>, <code>mustache</code>,
<code>slang</code> and <code>temel</code>.  Kilt will select the templating engine based on the
extension of the file so <code>index.ecr</code> will render the file using the ECR
engine.</p>

<p>The render method is configured to look in the "src/views" path to keep the
controllers simple.  You may also render with a layout which will look for
this in the "src/views/layouts" directory.</p>

<pre><code>render <span class="s">&quot;post/index.ecr&quot;</span>, <span class="s">&quot;main.ecr&quot;</span>
</code></pre>

<p>This will render the index.ecr template inside the main.ecr layout. All local
variables assigned in the controller are available in the templates.</p>

<p>An example <code>views/post/index.ecr</code>:</p>

<pre><code><span class="o"><</span><span class="o">%</span> posts.each <span class="k">do</span> <span class="o">|</span>post<span class="o">|</span> <span class="o">%</span><span class="o">></span>
  <span class="o"><</span>div<span class="o">></span>
    <span class="o"><</span>h2<span class="o">></span><span class="o"><</span>%= post.name <span class="o">%</span><span class="o">></span><span class="o"><</span><span class="s">/h2&gt;
    &lt;p&gt;&lt;&#37;&#61; post.body &#37;&gt;&lt;/</span>p<span class="o">></span>
    <span class="o"><</span>p<span class="o">></span>
      <span class="o"><</span>a href<span class="o">=</span><span class="s">&quot;/posts/&lt;&#37;&#61; post.id &#37;&gt;&quot;</span><span class="o">></span>read<span class="o"><</span><span class="s">/a&gt;
      | &lt;a href&#61;&quot;/</span>posts<span class="s">/&lt;&#37;&#61; post.id &#37;&gt;/</span>edit<span class="s">&quot;&gt;edit&lt;/a&gt; |
      &lt;a href&#61;&quot;</span><span class="s">/posts/</span><span class="o"><</span>%= post.id <span class="o">%</span><span class="o">></span>?_method<span class="o">=</span>delete<span class="s">&quot; onclick&#61;&quot;</span><span class="k">return</span> confirm(</code></pre>

<p>And an example of <code>views/layouts/main.ecr</code>:</p>

<pre><code><span class="o"><</span><span class="o">!</span><span class="t">DOCTYPE</span> html<span class="o">></span>
<span class="o"><</span>html<span class="o">></span>
  <span class="o"><</span>head<span class="o">></span>
    <span class="o"><</span>title<span class="o">></span><span class="t">Example</span> <span class="t">Layout</span><span class="o"><</span><span class="s">/title&gt;
    &lt;link rel&#61;&quot;stylesheet&quot; href&#61;&quot;/</span>stylesheets<span class="s">/main.css&quot;&gt;
  &lt;/</span>head<span class="o">></span>
  <span class="o"><</span>body<span class="o">></span>
    <span class="o"><</span>div <span class="k">class</span><span class="o">=</span><span class="s">&quot;container&quot;</span><span class="o">></span>
      <span class="o"><</span>div <span class="k">class</span><span class="o">=</span><span class="s">&quot;row&quot;</span><span class="o">></span>
        <span class="o"><</span>div <span class="k">class</span><span class="o">=</span><span class="s">&quot;col-sm-12&quot;</span><span class="o">></span>
          <span class="o"><</span>%= content <span class="o">%</span><span class="o">></span>
        <span class="o"><</span><span class="s">/div&gt;
      &lt;/</span>div<span class="o">></span>
    <span class="o"><</span><span class="s">/div&gt;
  &lt;/</span>body<span class="o">></span>
<span class="o"><</span><span class="s">/html&gt;</code></pre>

<p>The <code><%= content %></code> is where the template will be rendered in the layout.</p>

<h3>Models</h3>

<p>The models are a simple ORM mechanism that will map objects to rows in the
database.  The mapping is done using a <code>sql_mapping</code> macro.</p>

<p>An example <code>models/post.cr</code></p>

<pre><code class='language-crystal'><span class="k">require</span> <span class="s">&quot;kemalyst-model/adapter/pg&quot;</span>

<span class="k">class</span> <span class="t">Post</span> <span class="o"><</span> <span class="t">Kemalyst</span><span class="t">::</span><span class="t">Model</span>
  adapter pg

  sql_mapping({
    name: [<span class="s">&quot;VARCHAR&#40;255&#41;&quot;</span>, <span class="t">String</span>],
    body: [<span class="s">&quot;TEXT&quot;</span>, <span class="t">String</span>]
  })

<span class="k">end</span>
</code></pre>

<p>The mapping will automatically create the id, created_at and updated_at column
mapping that follows the active_record convention in Rails.</p>

<p>There are several methods that are provided in the model.</p>

<ul><li>self.drop - DROP table...</li><li>self.create - CREATE table...</li><li>self.clear - DELETE from table</li><li>self.migrate = Add/Update columns to match model definition</li><li>self.prune - Remove any undefined fields from the database</li><li>save - Insert or Update depending on if ID is set</li><li>destroy - DELETE FROM table WHERE id = this.id</li><li>all(where) SELECT * FROM table #{WHERE clause};"</li><li>find(id) - SELECT * FROM table WHERE id = this.id LIMIT 1;"</li></ul>

<p>You can find more details at <a href="https://github.com/drujensen/kemalyst-model" target="_blank">Kemalyst Model</a></p>

<h3>Validation</h3>

<p>Another Library included with Kemalyst is validation of your models.
You can find more details at <a href="https://github.com/drujensen/kemalyst-validators" target="_blank">Kemalyst Validators</a></p>

<h2>Contributing</h2>

<ol><li>Fork it ( https://github.com/drujensen/kemalyst/fork )</li><li>Create your feature branch (git checkout -b my-new-feature)</li><li>Commit your changes (git commit -am 'Add some feature')</li><li>Push to the branch (git push origin my-new-feature)</li><li>Create a new Pull Request</li></ol>

<h2>Contributors</h2>

<ul><li><a href="https://github.com/drujensen" target="_blank">drujensen</a> drujensen - creator, maintainer</li></ul>
</div>
</body>
</html>
